import io
import asyncio
from typing import Any

import httpx
from aiogram_dialog.widgets.input import MessageInput

from aiogram import Bot
from aiogram.types import CallbackQuery, Message, ContentType
from aiogram_dialog import DialogManager, StartMode
from aiogram_dialog.widgets.kbd import ManagedCheckbox

from opentelemetry.trace import SpanKind, Status, StatusCode

from internal import interface, model, common


class GeneratePublicationDialogService(interface.IGeneratePublicationDialogService):
    def __init__(
            self,
            tel: interface.ITelemetry,
            bot: Bot,
            state_repo: interface.IStateRepo,
            kontur_employee_client: interface.IKonturEmployeeClient,
            kontur_organization_client: interface.IKonturOrganizationClient,
            kontur_content_client: interface.IKonturContentClient,
    ):
        self.tracer = tel.tracer()
        self.logger = tel.logger()
        self.bot = bot
        self.state_repo = state_repo
        self.kontur_employee_client = kontur_employee_client
        self.kontur_organization_client = kontur_organization_client
        self.kontur_content_client = kontur_content_client

    async def handle_select_category(
            self,
            callback: CallbackQuery,
            widget: Any,
            dialog_manager: DialogManager,
            category_id: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_select_category",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                category = await self.kontur_content_client.get_category_by_id(
                    int(category_id)
                )

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –¥–∞–Ω–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∞
                dialog_manager.dialog_data["category_id"] = category.id
                dialog_manager.dialog_data["category_name"] = category.name
                dialog_manager.dialog_data["text_style"] = category.prompt_for_text_style
                dialog_manager.dialog_data["image_style"] = category.prompt_for_image_style

                self.logger.info(
                    "–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤—ã–±—Ä–∞–Ω–∞",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                        "category_id": category_id,
                        "category_name": category.name,
                    }
                )

                # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≤–≤–æ–¥—É —Ç–µ–∫—Å—Ç–∞
                await dialog_manager.switch_to(model.GeneratePublicationStates.input_text)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏", show_alert=True)
                raise

    async def handle_text_input(
            self,
            message: Message,
            widget: Any,
            dialog_manager: DialogManager,
            text: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_text_input",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                text = text.strip()


                if not text:
                    await message.answer("‚ùå –¢–µ–∫—Å—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                    return

                if len(text) < 10:
                    await message.answer("‚ùå –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ. –ù–∞–ø–∏—à–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ.")
                    return

                if len(text) > 2000:
                    await message.answer("‚ùå –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–º–∞–∫—Å. 2000 —Å–∏–º–≤–æ–ª–æ–≤).")
                    return

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—Å—Ç
                dialog_manager.dialog_data["input_text"] = text
                dialog_manager.dialog_data["has_input_text"] = True

                self.logger.info(
                    "–¢–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–≤–µ–¥–µ–Ω",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: message.chat.id,
                        "text_length": len(text),
                    }
                )
                await message.delete()

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞")
                raise

    async def handle_voice_input(
            self,
            message: Message,
            widget: MessageInput,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_voice_input",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                if message.content_type not in [ContentType.VOICE, ContentType.AUDIO]:
                    return

                await message.answer("üé§ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...")

                # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª
                if message.voice:
                    file_id = message.voice.file_id
                    duration = message.voice.duration
                else:
                    file_id = message.audio.file_id
                    duration = message.audio.duration

                if duration > 300:  # 5 –º–∏–Ω—É—Ç –º–∞–∫—Å
                    await message.answer("‚ùå –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (–º–∞–∫—Å. 5 –º–∏–Ω—É—Ç)")
                    return

                file = await self.bot.get_file(file_id)
                file_data = await self.bot.download_file(file.file_path)
                file_data = io.BytesIO(file_data.read())

                text = await self._convert_voice_to_text(file_data)

                if not text:
                    await message.answer(
                        "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. "
                        "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç."
                    )
                    return

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
                dialog_manager.dialog_data["input_text"] = text
                dialog_manager.dialog_data["has_input_text"] = True

                self.logger.info(
                    "–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: message.chat.id,
                        "voice_duration": duration,
                        "text_length": len(text),
                    }
                )

                # –û–±–Ω–æ–≤–ª—è–µ–º –æ–∫–Ω–æ
                await dialog_manager.update(dialog_manager.dialog_data)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è")
                raise

    async def handle_generate_text(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_generate_text",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                await callback.answer()
                loading_message = await callback.message.answer("üîÑ –ì–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ–∫—Å—Ç, —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è...")

                category_id = dialog_manager.dialog_data["category_id"]
                input_text = dialog_manager.dialog_data["input_text"]

                publication_data = await self.kontur_content_client.generate_publication_text(
                    category_id=category_id,
                    text_reference=input_text,
                )

                dialog_manager.dialog_data["publication_tags"] = publication_data["tags"]
                dialog_manager.dialog_data["publication_name"] = publication_data["name"]
                dialog_manager.dialog_data["publication_text"] = publication_data["text"]

                await loading_message.edit_text("‚úÖ –ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω!")
                await asyncio.sleep(3)
                try:
                    await loading_message.delete()
                except:
                    pass

                # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä—É
                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise

    async def handle_generate_text_with_image(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_generate_text_with_image",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                await callback.answer()
                loading_message = await callback.message.answer(
                    "üîÑ –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ–∫—Å—Ç –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è..."
                )

                category_id = dialog_manager.dialog_data["category_id"]
                input_text = dialog_manager.dialog_data["input_text"]

                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
                publication_data = await self.kontur_content_client.generate_publication_text(
                    category_id=category_id,
                    text_reference=input_text,
                )

                dialog_manager.dialog_data["publication_tags"] = publication_data.get("tags", [])
                dialog_manager.dialog_data["publication_name"] = publication_data["name"]
                dialog_manager.dialog_data["publication_text"] = publication_data["text"]

                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                image_url = await self.kontur_content_client.generate_publication_image(
                    category_id,
                    publication_data["text"],
                    input_text,
                )

                dialog_manager.dialog_data["publication_image_url"] = image_url
                dialog_manager.dialog_data["has_image"] = True
                dialog_manager.dialog_data["is_custom_image"] = False

                await loading_message.edit_text("‚úÖ –ü—É–±–ª–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!")
                await asyncio.sleep(2)
                try:
                    await loading_message.delete()
                except:
                    pass

                # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä—É
                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                raise

    async def handle_regenerate_text(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_regenerate_all",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                await callback.answer()
                loading_message = await callback.message.answer("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ–∫—Å—Ç, —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è...")

                category_id = dialog_manager.dialog_data["category_id"]
                current_text = dialog_manager.dialog_data["publication_text"]

                # –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ API
                regenerated_data = await self.kontur_content_client.regenerate_publication_text(
                    category_id=category_id,
                    publication_text=current_text,
                    prompt=None
                )

                # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
                dialog_manager.dialog_data["publication_name"] = regenerated_data["name"]
                dialog_manager.dialog_data["publication_text"] = regenerated_data["text"]
                dialog_manager.dialog_data["publication_tags"] = regenerated_data["tags"]

                await loading_message.edit_text("‚úÖ –ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω!")
                await asyncio.sleep(3)
                try:
                    await loading_message.delete()
                except:
                    pass

                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                raise

    async def handle_regenerate_text_with_prompt(
            self,
            message: Message,
            widget: Any,
            dialog_manager: DialogManager,
            prompt: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_regenerate_with_prompt",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                if not prompt.strip():
                    await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —É–∫–∞–∑–∞–Ω–∏—è –¥–ª—è –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
                    return

                loading_message = await message.answer("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä—É—é —Å —É—á–µ—Ç–æ–º –≤–∞—à–∏—Ö –ø–æ–∂–µ–ª–∞–Ω–∏–π...")

                category_id = dialog_manager.dialog_data["category_id"]
                current_text = dialog_manager.dialog_data["publication_text"]

                regenerated_data = await self.kontur_content_client.regenerate_publication_text(
                    category_id=category_id,
                    publication_text=current_text,
                    prompt=prompt
                )

                dialog_manager.dialog_data["publication_name"] = regenerated_data["name"]
                dialog_manager.dialog_data["publication_text"] = regenerated_data["text"]
                dialog_manager.dialog_data["publication_tags"] = regenerated_data["tags"]

                await loading_message.edit_text("‚úÖ –ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω!")
                await asyncio.sleep(3)
                try:
                    await loading_message.delete()
                except:
                    pass

                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
                raise

    async def handle_edit_title_save(
            self,
            message: Message,
            widget: Any,
            dialog_manager: DialogManager,
            text: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_edit_title_save",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                new_title = text.strip()

                if not new_title:
                    await message.answer("‚ùå –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
                    return

                if len(new_title) > 200:
                    await message.answer("‚ùå –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ (–º–∞–∫—Å. 200 —Å–∏–º–≤–æ–ª–æ–≤)")
                    return

                dialog_manager.dialog_data["publication_name"] = new_title

                await message.answer("‚úÖ –ù–∞–∑–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!")
                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                self.logger.info(
                    "–ù–∞–∑–≤–∞–Ω–∏–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–æ",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: message.chat.id,
                        "new_title": new_title,
                    }
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞–∑–≤–∞–Ω–∏—è")
                raise

    async def handle_edit_tags_save(
            self,
            message: Message,
            widget: Any,
            dialog_manager: DialogManager,
            text: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_edit_tags_save",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                # –ü–∞—Ä—Å–∏–º —Ç–µ–≥–∏ –∏–∑ —Å—Ç—Ä–æ–∫–∏
                tags_raw = text.strip()
                if not tags_raw:
                    dialog_manager.dialog_data["publication_tags"] = []
                    await message.answer("‚úÖ –¢–µ–≥–∏ —É–¥–∞–ª–µ–Ω—ã")
                else:
                    # –†–∞–∑–¥–µ–ª—è–µ–º –ø–æ –∑–∞–ø—è—Ç—ã–º –∏ –æ—á–∏—â–∞–µ–º
                    tags = [tag.strip() for tag in tags_raw.split(",")]
                    tags = [tag for tag in tags if tag]  # –£–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ

                    if len(tags) > 10:
                        await message.answer("‚ùå –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Ç–µ–≥–æ–≤ (–º–∞–∫—Å. 10)")
                        return

                    dialog_manager.dialog_data["publication_tags"] = tags
                    await message.answer(f"‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(tags)} —Ç–µ–≥–æ–≤")

                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç–µ–≥–æ–≤")
                raise

    async def handle_edit_content_save(
            self,
            message: Message,
            widget: Any,
            dialog_manager: DialogManager,
            text: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_edit_content_save",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                new_text = text.strip()

                if not new_text:
                    await message.answer("‚ùå –¢–µ–∫—Å—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
                    return

                if len(new_text) > 4000:
                    await message.answer("‚ùå –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (–º–∞–∫—Å. 4000 —Å–∏–º–≤–æ–ª–æ–≤)")
                    return

                if len(new_text) < 50:
                    await message.answer("‚ö†Ô∏è –¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ú–∏–Ω–∏–º—É–º 50 —Å–∏–º–≤–æ–ª–æ–≤.")
                    return

                dialog_manager.dialog_data["publication_text"] = new_text

                await message.answer("‚úÖ –¢–µ–∫—Å—Ç –æ–±–Ω–æ–≤–ª–µ–Ω!")
                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                self.logger.info(
                    "–¢–µ–∫—Å—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∏–∑–º–µ–Ω–µ–Ω",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: message.chat.id,
                        "text_length": len(new_text),
                    }
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞")
                raise

    async def handle_generate_new_image(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_generate_new_image",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                await callback.answer()
                loading_message = await callback.message.answer("üîÑ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è...")

                category_id = dialog_manager.dialog_data["category_id"]
                publication_text = dialog_manager.dialog_data["publication_text"]
                text_reference = dialog_manager.dialog_data["input_text"]

                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ API
                image_url = await self.kontur_content_client.generate_publication_image(
                    category_id=category_id,
                    publication_text=publication_text,
                    text_reference=text_reference,
                    prompt=None
                )

                dialog_manager.dialog_data["publication_image_url"] = image_url
                dialog_manager.dialog_data["has_image"] = True

                await loading_message.edit_text("‚úÖ –¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!")
                await asyncio.sleep(3)
                try:
                    await loading_message.delete()
                except:
                    pass

                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è", show_alert=True)
                raise

    async def handle_generate_image_with_prompt(
            self,
            message: Message,
            widget: Any,
            dialog_manager: DialogManager,
            prompt: str
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_generate_image_with_prompt",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                if not prompt.strip():
                    await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                    return

                loading_message = await message.answer("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä—É—é —Å —É—á–µ—Ç–æ–º –≤–∞—à–∏—Ö –ø–æ–∂–µ–ª–∞–Ω–∏–π...")

                category_id = dialog_manager.dialog_data["category_id"]
                publication_text = dialog_manager.dialog_data["publication_text"]
                text_reference = dialog_manager.dialog_data["input_text"]

                image_url = await self.kontur_content_client.generate_publication_image(
                    category_id=category_id,
                    publication_text=publication_text,
                    text_reference=text_reference,
                    prompt=prompt
                )

                dialog_manager.dialog_data["publication_image_url"] = image_url
                dialog_manager.dialog_data["has_image"] = True

                await loading_message.edit_text("‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω!")
                await asyncio.sleep(3)
                try:
                    await loading_message.delete()
                except:
                    pass
                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                raise

    async def handle_image_upload(
            self,
            message: Message,
            widget: MessageInput,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_image_upload",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                if message.content_type != ContentType.PHOTO:
                    await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")
                    return

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
                if message.photo:
                    # –ë–µ—Ä–µ–º —Ñ–æ—Ç–æ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ–º
                    photo = message.photo[-1]

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
                    if hasattr(photo, 'file_size') and photo.file_size:
                        if photo.file_size > 10 * 1024 * 1024:  # 10 –ú–ë
                            await message.answer("‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10 –ú–ë)")
                            return

                    await message.answer("üì∏ –ó–∞–≥—Ä—É–∂–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")

                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º file_id –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                    dialog_manager.dialog_data["custom_image_file_id"] = photo.file_id
                    dialog_manager.dialog_data["has_image"] = True
                    dialog_manager.dialog_data["is_custom_image"] = True

                    # –£–¥–∞–ª—è–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –µ—Å–ª–∏ –±—ã–ª–æ
                    dialog_manager.dialog_data.pop("publication_image_url", None)

                    self.logger.info(
                        "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ",
                        {
                            common.TELEGRAM_CHAT_ID_KEY: message.chat.id,
                            "file_id": photo.file_id,
                            "file_size": getattr(photo, 'file_size', 'unknown'),
                        }
                    )

                    await message.answer("‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ!")
                    await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                    span.set_status(Status(StatusCode.OK))
                else:
                    await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")

            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                raise

    async def handle_remove_image(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        """–£–¥–∞–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏"""
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_remove_image",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                # –£–¥–∞–ª—è–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–± –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
                dialog_manager.dialog_data["has_image"] = False
                dialog_manager.dialog_data.pop("publication_image_url", None)
                dialog_manager.dialog_data.pop("custom_image_file_id", None)
                dialog_manager.dialog_data.pop("is_custom_image", None)

                await callback.answer("‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ", show_alert=True)
                await dialog_manager.switch_to(model.GeneratePublicationStates.preview)

                self.logger.info(
                    "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ –∏–∑ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                    }
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è", show_alert=True)
                raise

    async def handle_add_to_drafts(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_add_to_drafts",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                state = await self._get_state(dialog_manager)

                category_id = dialog_manager.dialog_data["category_id"]
                text_reference = dialog_manager.dialog_data["input_text"]
                tags = dialog_manager.dialog_data["publication_tags"]
                name = dialog_manager.dialog_data["publication_name"]
                text = dialog_manager.dialog_data["publication_text"]

                # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ–± –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
                image_url = dialog_manager.dialog_data.get("publication_image_url")  # –æ—Ç OpenAI
                image_content = None
                image_filename = None

                # –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ Telegram
                telegram_file_id = dialog_manager.dialog_data.get("custom_image_file_id")
                if telegram_file_id:
                    file = await self.bot.get_file(telegram_file_id)
                    file_data = await self.bot.download_file(file.file_path)
                    image_content = file_data.read()
                    image_filename = f"user_image_{telegram_file_id[:8]}.jpg"

                    self.logger.info(
                        "–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏",
                        {
                            common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                            "file_id": telegram_file_id,
                            "image_size": len(image_content),
                        }
                    )

                # –í—ã–∑—ã–≤–∞–µ–º HTTP –∫–ª–∏–µ–Ω—Ç —Å –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
                await self.kontur_content_client.create_publication(
                    state.organization_id,
                    category_id,
                    state.account_id,
                    text_reference,
                    name,
                    text,
                    tags,
                    "draft",
                    image_url=image_url,
                    image_content=image_content,
                    image_filename=image_filename,
                )

                self.logger.info(
                    "–ü—É–±–ª–∏–∫–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ —á–µ—Ä–Ω–æ–≤–∏–∫–∏",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                        "has_generated_image": bool(image_url),
                        "has_user_image": bool(image_content),
                    }
                )

                await callback.answer("üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ —á–µ—Ä–Ω–æ–≤–∏–∫–∏!", show_alert=True)

                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞
                await dialog_manager.start(
                    model.ContentMenuStates.content_menu,
                    mode=StartMode.RESET_STACK
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è", show_alert=True)
                raise

    async def handle_send_to_moderation(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_send_to_moderation",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                state = await self._get_state(dialog_manager)

                category_id = dialog_manager.dialog_data["category_id"]
                text_reference = dialog_manager.dialog_data["input_text"]
                tags = dialog_manager.dialog_data["publication_tags"]
                name = dialog_manager.dialog_data["publication_name"]
                text = dialog_manager.dialog_data["publication_text"]

                # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                image_url = dialog_manager.dialog_data.get("publication_image_url")
                image_content = None
                image_filename = None

                telegram_file_id = dialog_manager.dialog_data.get("custom_image_file_id")
                if telegram_file_id:
                    file = await self.bot.get_file(telegram_file_id)
                    file_data = await self.bot.download_file(file.file_path)
                    image_content = file_data.read()
                    image_filename = f"user_image_{telegram_file_id[:8]}.jpg"

                    self.logger.info(
                        "–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏",
                        {
                            common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                            "file_id": telegram_file_id,
                            "image_size": len(image_content),
                        }
                    )

                await self.kontur_content_client.create_publication(
                    state.organization_id,
                    category_id,
                    state.account_id,
                    text_reference,
                    name,
                    text,
                    tags,
                    "moderation",  # —Å—Ç–∞—Ç—É—Å –º–æ–¥–µ—Ä–∞—Ü–∏–∏
                    image_url=image_url,
                    image_content=image_content,
                    image_filename=image_filename,
                )

                self.logger.info(
                    "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                        "has_generated_image": bool(image_url),
                        "has_user_image": bool(image_content),
                    }
                )

                await callback.answer("üíæ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é!", show_alert=True)

                await dialog_manager.start(
                    model.ContentMenuStates.content_menu,
                    mode=StartMode.RESET_STACK
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏", show_alert=True)
                raise

    async def handle_publish(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_publish",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å
                await callback.answer("üöß –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ", show_alert=True)

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏", show_alert=True)
                raise

    async def handle_platform_toggle(
            self,
            callback: CallbackQuery,
            checkbox: ManagedCheckbox,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_platform_toggle",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ª–æ–≤–∞—Ä—å –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
                if "selected_platforms" not in dialog_manager.dialog_data:
                    dialog_manager.dialog_data["selected_platforms"] = {}

                platform_id = checkbox.widget_id
                is_checked = checkbox.is_checked()

                dialog_manager.dialog_data["selected_platforms"][platform_id] = is_checked

                self.logger.info(
                    "–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∞",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: callback.message.chat.id,
                        "platform": platform_id,
                        "selected": is_checked,
                    }
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise

    async def handle_go_to_content_menu(
            self,
            callback: CallbackQuery,
            button: Any,
            dialog_manager: DialogManager
    ) -> None:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.handle_go_to_content_menu",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                await dialog_manager.start(
                    model.ContentMenuStates.content_menu,
                    mode=StartMode.RESET_STACK
                )

                span.set_status(Status(StatusCode.OK))
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise

    async def get_categories_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.get_categories_data",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                state = await self._get_state(dialog_manager)
                employee = await self.kontur_employee_client.get_employee_by_account_id(
                    state.account_id
                )

                # –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
                categories = await self.kontur_content_client.get_categories_by_organization(
                    employee.organization_id
                )

                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                categories_data = []
                for category in categories:
                    categories_data.append({
                        "id": category.id,
                        "name": category.name,
                        "text_style": category.prompt_for_text_style,
                        "image_style": category.prompt_for_image_style,
                    })

                data = {
                    "categories": categories_data,
                    "has_categories": len(categories_data) > 0,
                }

                self.logger.info(
                    "–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã",
                    {
                        common.TELEGRAM_CHAT_ID_KEY: self._get_chat_id(dialog_manager),
                        "categories_count": len(categories_data),
                    }
                )

                span.set_status(Status(StatusCode.OK))
                return data
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise err

    async def get_input_text_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        return {
            "category_name": dialog_manager.dialog_data.get("category_name", ""),
            "input_text": dialog_manager.dialog_data.get("input_text", ""),
            "has_input_text": dialog_manager.dialog_data.get("has_input_text", False),
        }

    async def get_preview_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.get_preview_data",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                state = await self._get_state(dialog_manager)
                employee = await self.kontur_employee_client.get_employee_by_account_id(
                    state.account_id
                )

                tags = dialog_manager.dialog_data.get("publication_tags", [])
                name = dialog_manager.dialog_data.get("publication_name", "")
                text = dialog_manager.dialog_data.get("publication_text", "")

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                has_image = False
                preview_image_media = None

                # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ > —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ
                if dialog_manager.dialog_data.get("custom_image_file_id"):
                    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    has_image = True
                    from aiogram_dialog.api.entities import MediaAttachment, MediaId

                    file_id = dialog_manager.dialog_data["custom_image_file_id"]
                    preview_image_media = MediaAttachment(
                        file_id=MediaId(file_id),
                        type=ContentType.PHOTO
                    )
                elif dialog_manager.dialog_data.get("publication_image_url"):
                    # –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    has_image = True
                    from aiogram_dialog.api.entities import MediaAttachment

                    image_url = dialog_manager.dialog_data["publication_image_url"]
                    preview_image_media = MediaAttachment(
                        url=image_url,
                        type=ContentType.PHOTO
                    )

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏
                requires_moderation = employee.required_moderation
                can_publish_directly = not requires_moderation

                data = {
                    "category_name": dialog_manager.dialog_data.get("category_name", ""),
                    "publication_name": name,
                    "publication_text": text,
                    "has_tags": bool(tags),
                    "publication_tags": ", ".join(tags) if tags else "",
                    "has_scheduled_time": False,
                    "publish_time": "",
                    "has_image": has_image,
                    "preview_image_media": preview_image_media,
                    "requires_moderation": requires_moderation,
                    "can_publish_directly": can_publish_directly,
                    "is_custom_image": dialog_manager.dialog_data.get("is_custom_image", False),
                }

                span.set_status(Status(StatusCode.OK))
                return data
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise err

    async def get_publish_locations_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–∫–Ω–∞ –≤—ã–±–æ—Ä–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º"""
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService.get_publish_locations_data",
                kind=SpanKind.INTERNAL
        ) as span:
            try:
                state = await self._get_state(dialog_manager)
                employee = await self.kontur_employee_client.get_employee_by_account_id(
                    state.account_id
                )

                # TODO: –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏–∑ API –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏
                # organization_platforms = await self.kontur_organization_client.get_connected_platforms(
                #     employee.organization_id
                # )

                # –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ç–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                platforms_data = dialog_manager.dialog_data.get("selected_platforms", {})
                selected_count = sum(1 for selected in platforms_data.values() if selected)

                data = {
                    "telegram_available": True,
                    "vkontakte_available": True,
                    "has_selected_platforms": selected_count > 0,
                    "selected_count": selected_count,
                }

                span.set_status(Status(StatusCode.OK))
                return data
            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise err

    async def get_regenerate_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        """–î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–∫–Ω–∞ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å –ø—Ä–æ–º–ø—Ç–æ–º"""
        return {
            "has_regenerate_prompt": dialog_manager.dialog_data.get("regenerate_prompt", "") != "",
            "regenerate_prompt": dialog_manager.dialog_data.get("regenerate_prompt", ""),
        }

    async def get_image_menu_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        """–î–∞–Ω–Ω—ã–µ –¥–ª—è –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º"""
        return {
            "has_image": dialog_manager.dialog_data.get("has_image", False),
            "is_custom_image": dialog_manager.dialog_data.get("is_custom_image", False),
        }

    async def get_image_prompt_data(
            self,
            dialog_manager: DialogManager,
            **kwargs
    ) -> dict:
        """–î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–∫–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø—Ä–æ–º–ø—Ç–æ–º"""
        return {
            "has_image_prompt": dialog_manager.dialog_data.get("image_prompt", "") != "",
            "image_prompt": dialog_manager.dialog_data.get("image_prompt", ""),
        }

    async def _convert_voice_to_text(self, voice_data: io.BytesIO) -> str:
        text = await self.kontur_content_client.transcribe_audio(
            audio_content=voice_data.read(),
            audio_filename=voice_data.name,
        )
        return text

    async def _get_state(self, dialog_manager: DialogManager) -> model.UserState:
        chat_id = self._get_chat_id(dialog_manager)
        return await self._get_state_by_chat_id(chat_id)

    async def _get_state_by_chat_id(self, chat_id: int) -> model.UserState:
        state = await self.state_repo.state_by_id(chat_id)
        if not state:
            raise ValueError(f"State not found for chat_id: {chat_id}")
        return state[0]

    def _get_chat_id(self, dialog_manager: DialogManager) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å chat_id –∏–∑ dialog_manager"""
        if hasattr(dialog_manager.event, 'message') and dialog_manager.event.message:
            return dialog_manager.event.message.chat.id
        elif hasattr(dialog_manager.event, 'chat'):
            return dialog_manager.event.chat.id
        else:
            raise ValueError("Cannot extract chat_id from dialog_manager")

    async def _download_image_from_url(
            self,
            image_url: str
    ) -> bytes:
        with self.tracer.start_as_current_span(
                "GeneratePublicationDialogService._download_image_from_url",
                kind=SpanKind.CLIENT,
        ) as span:
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(image_url)
                    response.raise_for_status()

                span.set_status(Status(StatusCode.OK))
                return response.content

            except Exception as err:
                span.record_exception(err)
                span.set_status(Status(StatusCode.ERROR, str(err)))
                raise
